# Hprose 3.0 设计与实现

本文档重点讲述 Hprose 3.0 的 RPC 核心构架的设计，该设计是通用的，与具体的序列化格式和 RPC 协议编码方式无关。其次，会讲解在具体实现时可能遇到的问题以及解决方法。

## 设计目标

* 跨语言跨平台
* 编码层可替换
* 传输层可替换
* 具有扩展机制

## 构架图

```
            +------+                         +--------+          
            |Invoke|                         |Execute |          
            +------+                         +--------+          
             |    ^                            |    ^            
             v    |                            v    |            
        +--------------+                  +--------------+       
        |InvokeHandlers|                  |InvokeHandlers|       
        +--------------+                  +--------------+       
          |          ^                      |          ^         
          v          |                      v          |         
       +------+  +------+                +------+  +------+      
       |Encode|  |Decode|                |Encode|  |Decode|      
       +------+  +------+                +------+  +------+      
            |      ^                          |      ^           
            v      |                          v      |           
          +----------+                      +----------+         
          |IOHandlers|                      |IOHandlers|         
          +----------+                      +----------+         
            |      ^                          |      ^           
            v      |                          v      |           
          +----------+                       +--------+          
          |Transports|---------------------->|Handlers|          
          +----------+                       +--------+          
               ^                                 |              
               |                                 |              
               +---------------------------------+              
                                                                 
  ____ _    _ ____ _  _ ___     ____ ____ ____ _  _ _ ____ ____  
  |    |    | |___ |\ |  |      [__  |___ |__/ |  | | |    |___  
  |___ |___ | |___ | \|  |      ___] |___ |  \  \/  | |___ |___  
                                                                 
```

## 构架简介

通过上面的构架图，我们可以大致了解 Hprose RPC 的工作流程。上图左面部分是客户端，右面部分是服务端。客户端和服务端的执行流程是对称且相反的两个过程。

客户端首先发起调用，原始的调用请求会通过调用处理器进行处理，之后经过处理的调用请求被编码为序列化后的 RPC 请求，编码之后的请求再通过输入输出处理器进行处理，最后通过传输层发送到服务端。

服务端的处理器将接收到的客户端发来的序列化后的 RPC 请求转发给输入输出处理器进行处理，然后处理过后的序列化 RPC 请求被解码为原始调用请求再转发给调用处理器，调用处理器处理后，请求被执行，并将执行结果按原路层层返回给客户端。

在该调用过程中，客户端和服务端的各自存在一个上下文对象（`Context`）。也就是说，除了请求和结果会在以上过程中被传递以外，上下文对象也会在以上过程中被传递。但是上下文对象并不会从客户端传递给服务端，也不会从服务端传递给客户端，上下文对象在客户端和服务端是各自独立的。

客户端上下文对象（`ClientContext`）和服务端的上下文对象（`ServiceContext`）继承自同一个上下文对象（`Context`）的结构。通过这种抽象，就可以将调用处理器（`InvokeHandler`）和输入输出处理器（`IOHandler`）设计为在客户端和服务端通用的形式了。

调用处理器（`InvokeHandler`）和输入输出处理器（`IOHandler`）用来实现可扩展的插件机制。

它们具有相同的工作模式，只是接口和所处理的数据有所不同。

不论客户端还是服务端，这两种类型的处理器都可以添加任意多个并可进行自由组合。

客户端和服务的各自拥有独立的编解码器（`Codec`），默认的编解码器使用 Hprose 序列化和 Hprose RPC 协议进行编解码处理。

编解码器是可替换的，通过替换编解码器，Hprose 客户端或服务端可以变身为其它 RPC 的客户端或服务端。例如，如果实现了 JSONRPC 编解码器，Hprose 客户端和服务端就完全可以作为 JSONRPC 的客户端和服务端来使用，并且可以与其它方式实现的 JSONRPC 客户端或服务端进行互通。

在上面的构架图中，客户端的传输层被抽象为一个 `Transport` 对象，而服务的传输层处理器被抽象为一个 `Handler` 对象。可以为不同的传输协议提供不同的实现，将实现的传输层对象在客户端和服务端的进行注册后，就可以使用该传输层协议进行通讯了。客户端和服务端都可以注册多种传输协议，并可以增加替换，还能混合使用。

## 上下文对象

上下文对象（`Context`）是一个类似于 `Map<String, Object>` 的结构，用户可以用字符串做 `Key`，放入任何类型的数据。因为该对象不需要在客户端和服务端进行传输，所以它当中存放的数据，不必是可序列化类型。

上下文对象具有判断某个 `Key` 是否存在的功能，但是在不同语言实现时，可以根据各自语言的特性在语法或方法命名上有所不同。

上下文对象还应具有一个 `clone` 方法，该方法名在大小写上，可以根据不同语言有所区别。

在调用中，每个调用都具有自己独立的上下文对象，

客户端上下文对象（`ClientContext`）继承自上下文对象（`Context`），它在客户端进行调用前由用户创建，或者在客户端进行调用时被自动创建，也就是从客户端调用的入口处被创建。它增加了一些专属于客户端的属性，例如：

* 客户端对象（`client`)
* 服务地址（`uri`）
* 调用返回值类型（`returnType`）
* 调用超时时长（`timeout`）
* 请求头部（`requestHeaders`）
* 响应头部（`responseHeaders`）

每种语言在实现时，这些属性在命名上可能会有大小写上的区别。

在插件处理器中，可以通过调用原始上下文对象上的 `clone` 方法创建多个上下文对象副本，然后通过修改副本上下文对象上的服务地址（`uri`）属性，将一个调用变为对多个不同服务的调用。

服务端上下文对象（`ServiceContext`）也继承自上下文对象（`Context`），它在服务端由 `Handler` 对象创建，也就是在服务端的入口处被创建。它增加了一些专属于服务端的属性，例如：

* 服务对象（`service`）
* 服务处理器对象（`handler`)
* 服务方法（`method`）
* 客户端地址（`address`）
* 请求头部（`requestHeaders`）
* 响应头部（`responseHeaders`）

每种语言在实现时，这些属性在命名上可能会有大小写上的区别。其中客户端地址属性在不同的语言中因为类型差别较大，所以命名上没有统一要求。

从上面的描述中我们可以看到，不论客户端还是服务端的上下文对象中，都包含有请求头部（`requestHeaders`）和响应头部（`responseHeaders`）这两个属性。这两个属性比较特殊，它们也是一个类似于 `Map<String, Object>` 的类型，但是客户端的请求头部（`requestHeaders`）会跟随请求一起发送给服务端，而服务端的响应头部（`responseHeaders`）会跟随响应一起发送给客户端，因此，这两个属性中添加的数据必须是可序列化的类型。

用户也可以自定义上下文对象类型，但是必须继承自客户端上下文对象（`ClientContext`）或服务端上下文对象（`ServiceContext`）。自定义上下文对象类型可以在插件处理器中对现有的上下文对象进行包装然后传递到下一层去。但是通常不需要这样做，直接使用 `key-value` 方式在现有上下文对象中存取用户数据是更通用的做法。

## 服务方法

在上面介绍上下文对象时，我们提到在服务端上下文对象（`ServiceContext`）包含有一个服务方法（`method`）属性。该属性对应服务端发布的服务方法，该属性的类型在不同语言中的定义会有所不同，它其中包含了关于服务方法的一些必要信息，比如发布名称（区别于方法定义的名称），方法本体（可以反射调用或直接调用的方法对象），方法所属对象，参数类型，是否是通用方法，参数中是否包含有上下文对象等等。

## 服务方法管理器

服务方法（`Method`）由服务方法管理器（`MethodManager`）来统一管理，服务方法管理器包含以下一些必须的方法：

* `getNames`
* `add`
* `get`
* `remove`
* `addMissingMethod`

其中 `getNames` 方法返回所有已发布的方法名列表，该方法本身也会作为一个特殊的服务方法被发布，为了避免跟用户发布的方法有命名冲突，在发布时，该方法是以特殊字符 `~` 来作为发布名称来发布的。

`add` 方法用来添加发布的服务方法。该方法在不同的语言中，可以根据具体情况下提供多个重载或不同命名的多个实现，例如：`addMethod`，`addMethods`，`addFunction`，`addFunctions`，`addStaticMethods`，`addInstanceMethods` 等等。

`get` 方法用来通过发布名称获取已发布的服务方法对象。在某些语言中（比如 C#），允许发布相同名称但参数个数不同的重载方法，因此，在这些语言中，`get` 方法本身会有 2 个参数（发布名称，参数个数）。

`remove` 方法用来删除已发布的服务方法。该方法的参数与 `get` 方法相同。


`addMissingMethod` 方法用来添加一个通用的服务方法，当客户端调用的服务方法不存在时，该服务方法才会被调用。该方法的名称在服务方法管理器中，以一个特殊字符 `*` 来表示，客户端不应直接调用此方法。

当调用 `get` 方法时，如果查找的具体服务方法不存在，但是通用服务方法存在的话，则会返回通用服务方法，否则返回 `null`。

用户通常不需要直接使用服务方法管理器（`MethodManager`），因为在服务端 `Service` 类型中它是作为一个内部属性出现的，它所包含的方法也是由 `Service` 类型对象所暴露的。

但是当开发插件时，如果需要用到服务发布管理的功能，用户可以在插件中使用服务方法管理器（`MethodManager`），例如在反向调用插件的实现中，就使用了服务方法管理器（`MethodManager`）。

